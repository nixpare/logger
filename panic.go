package logger

import (
	"errors"
	"fmt"
	"runtime/debug"
	"strings"
)

// PanicError is the data used to capture any function returning an error
// and any generated panic. If Err is set, means that the function returned
// an error without panicking, instead if PanicErr is set, this means that
// the function returned prematurely due to a panic: the panic error is set
// and the stack trace is provided in the relative field
type PanicError struct {
	Err      error
	PanicErr error
	Stack    string
}

// PanicToErr runs any function that returns an error in a panic-controlled
// environment and converts any panic (if any) into an error. Expecially, the
// error generated by a panic can be unwrapped to get rid of the stack trace (
// or manipulated to separate the error from the stack trace)
func PanicToErr(f func() error) *PanicError {
	errChan := make(chan *PanicError)

	go func() {
		defer func() {
			err := recover()

			if err == nil {
				errChan <- nil
			} else {
				switch err := err.(type) {
				case error:
					errChan <- &PanicError{
						PanicErr: fmt.Errorf("%w", err),
						Stack:    Stack(),
					}
				default:
					errChan <- &PanicError{
						PanicErr: fmt.Errorf("%v", err),
						Stack:    Stack(),
					}
				}
			}

			close(errChan)
		}()

		if err := f(); err == nil {
			errChan <- nil
		} else {
			errChan <- &PanicError{Err: err}
		}
	}()

	return <-errChan
}

func (err PanicError) error() error {
	if err.PanicErr != nil {
		return fmt.Errorf("%w\n%s", err.PanicErr, IndentString(err.Stack, 2))
	}
	
	return err.Err
}

func (err PanicError) Error() string {
	return err.error().Error()
}

func (err PanicError) Unwrap() error {
	var res error
	if err.PanicErr != nil {
		res = err.PanicErr
	} else if err.Err != nil {
		res = err.Err
	}

	unwrap := errors.Unwrap(res)
	if unwrap != nil {
		return unwrap
	}
	return res
}

func (err PanicError) String() string {
	return err.Error()
}

// Stack returns the execution stack. This must be called after
// a panic (during a recovery) because it strips the first lines
// where are reported also the recovery functions, returning only
// the panic-reletate stuff. If this is not desired just use the
// standard debug.Stack
func Stack() string {
	var out string

	split := strings.Split(string(debug.Stack()), "\n")
	cont := true

	for _, s := range split {
		if strings.HasPrefix(s, "panic(") {
			cont = false
		}

		if cont {
			continue
		}

		out += s + "\n"
	}

	return strings.TrimRight(out, "\n")
}
